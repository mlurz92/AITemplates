# Prompt-Templates Browser: Vollständige Technische Dokumentation & Entwickler-Handbuch

## 1. Projekt-Übersicht & Kernvision

Der **Prompt-Templates Browser** ist eine **Progressive Web App (PWA)** als kompakte Single-Page-Anwendung (SPA), die eine intuitive, hierarchische Verwaltung von Text-Prompts (Templates) ermöglicht. Die App dient der schnellen Navigation durch Ordnerstrukturen, Bearbeitung von Prompts, Drag-and-Drop-Organisation, Favoriten-Verwaltung mit visueller Identifikation und effizienten Kopier-Workflows. Kernvision: Ein natives, latenzfreies Erlebnis mit minimalem Overhead – Vanilla JavaScript (keine Frameworks), <50KB Bundle-Größe, GPU-beschleunigte Animationen und offline-fähige Persistenz via `localStorage`. Zielnutzer: Content-Creator, die Prompts (z. B. für AI-Tools) organisieren und kopieren möchten, ohne Abhängigkeiten von externen Services.

**Technische Highlights**:
- **Offline-fähig**: Templates laden via `fetch('templates.json')` oder `localStorage` (Key: 'customTemplatesJson' mit JSON.stringify(null,2) für Formatierung); Änderungen persistieren sofort (z. B. Add/Edit/Delete/Move via `persistJsonData()` mit Try-Catch für Parse-Errors: removeItem + Reload).
- **Performance**: Throttled Events (RAF für Scroll/Animations), O(n) Rendering (max 36 Items pro View, slice(0,36) in `renderView`), GPU-Layers (will-change transform/opacity/filter/backdrop-filter), keine Reflows (transform/opacity-only).
- **PWA-Features**: Manifest.json (Name: "Prompt-Templates Browser", short_name: "Prompts", Icons: 192x192/512x512 PNG maskable, start_url: "index.html", display: "standalone", theme: "#0c0f17"); Installierbar via Browser (Chrome/Edge: Adressleiste-Button); Service-Worker-erweiterbar für volles Offline-Caching.
- **Design-Philosophie**: "Layered Glassmorphism" – Transparente Overlays (backdrop-filter: blur(20px) saturate(200%) + radial Highlights/Shadows + SVG-Noise-Texture + Gradient-Borders via ::before exclude-Mask) auf dunklem Hintergrund (hsl(228,12%,8%)) mit Aurora-Parallax (3 Shapes: translate/scale alternate 30-50s, blur 100px, plus-lighter blend 0.15 opacity). Akzente: --acc-1 #8b5cf6 (Lila), --acc-2 #00e6ff (Cyan). Alle Effekte GPU-freundlich, Reduced-Motion-kompatibel (prefers-reduced-motion: reduce → * animation/transition none !important).
- **Code-Struktur**: Modular (z. B. `renderView` für DOM-Loop + Vivus-Setup, `toggleFavoritesBarExpansion` für State-Sync), ~2247 LOC in script.js, 896 Zeilen CSS, 334 Zeilen HTML. Externe Libs: Vivus 0.4.6 (CDN, delayed 100ms manual für Folder-SVGs), SortableJS latest (CDN, 200ms animation ghost 'sortable-ghost' opacity 0.7 dashed acc-2 border). Keine Builds; Vanilla JS mit DOM-Manipulation, Event-Delegation und rekursiven Hilfsfunktionen (z. B. `findNodeById` rekursiv mit for-of items).

**Dateigrößen (uncompressed)**: HTML 9.2KB, CSS 28.4KB, JS 68.7KB, JSON 2.1KB, SVG 7.5KB, Icons ~33KB → Total ~115KB (gzip ~35KB). Runtime mit Libs ~95KB.

## 2. Einrichtung & Entwicklung

### 2.1. Lokale Entwicklung
1. **Voraussetzungen**: Moderner Browser (Chrome 91+, Firefox 105+, Safari 15.4+ für View-Transitions; Fallback: direct callback in `performViewTransition`). HTTPS für Clipboard-API (Fallback: `execCommand` mit fixed textarea top/left -9999px opacity 0, append/remove body).
2. **Setup**: 
   - Dateien herunterladen (index.html, style.css, script.js, templates.json, favicon_animated.svg, manifest.json).
   - HTTP-Server starten (z. B. `npx serve .` oder Python `http.server 8000`) – `file://` funktioniert teilweise (kein Clipboard, aber Storage/Fetch fallback).
   - Öffnen: http://localhost:8000/index.html.
3. **PWA-Installation**: Browser-Menü "Apps installieren" oder Adressleiste-Icon; Manifest.json definiert Icons (192x192/512x512 PNG, purpose "any maskable" für Android Adaptive Icons), start_url "index.html", display "standalone", theme "#0c0f17" (dunkel, passt zu --bg-0).
4. **Test-Umgebungen**:
   - **Desktop**: Chrome DevTools (Viewport >1024px: 5-6 Karten-Spalten, auto-fit minmax(120px,1fr) gap 1.5rem; Favoriten: 6-8 Items horizontal flex-basis 130px min-width 130px gap 0.6rem; Tab: 52x36px right 1rem bottom calc(4.5rem + safe -1px), hover translateY -2px shadow increase; Animationen: View-Transitions slide 35px opacity 0→1 0.35s ease-smooth; Copy: 600ms filter drop-shadow 0 0 8px acc-2 scale 1→1.15 at 30%; Icon-Rotation 180deg 600ms smooth via .is-expanded; Jiggle 0.4s infinite rotate -0.5→0.5deg translateY 0→-1px in edit-mode; Parallax Aurora translateY *0.3 on scroll).
   - **Tablet (768-1024px)**: 3-4 Karten-Spalten gap 1.2rem padding 1.5rem; Top-Bar kompakt gap 0.5rem; Favoriten 4-6 Items flex-basis 130px height 42px font 0.9rem; innerWidth >=768 → no 'mobile-grid' class (CSS behält horizontal flex); Expand: 2 Spalten grid minmax(140px,1fr) gap 0.8rem vertical auto; Tab konsistent 52x36px bottom calc(4.5/12rem + safe -1px); Hover/Touch-Mix: Mouseenter showTooltip 50ms delay (position top/left collision margin 10px visibility hidden→visible RAF, max-width 320px line 1.5 white-space pre-wrap); Touchstart passive false preventDefault in Favoriten (no Zoom/Scroll bei Klick, präzise Target).
   - **Mobile (<768px, <420px speziell)**: Karten 3 Spalten gap 0.6rem padding 0.6rem top calc(5.5rem + safe); Top-Bar min-height 3.5rem Icons 20px; Fixed-Back left 1.2rem top 50% translateY -50% padding 0.7rem (hidden at Home, visible if pathStack.length>0 || currentNode != jsonData); Favoriten: innerWidth <768 → add 'mobile-grid' class (CSS-Trigger für erweiterte Responsivität, z.B. height 38px padding 0.75 safe-areas, flex-basis/min-width 110px gap 0.4rem font 0.85rem); Initial-Badge 24px font 0.85rem, Title max 60px font 0.8rem, Icon 18px; Expand: 1fr grid (vertikales Stack full-width overflow-y auto padding-right 1.5rem); Tab: 48x32px right 0.75rem bottom calc(4.5rem + safe -1px) collapsed, calc(12rem + safe -1px) expanded; Touch: Swipe-Back (handleTouchStart X/Y = touches[0].clientX/Y end = X/Y; move endX/Y = touches[0]; diffX = endX - startX; if |diffX| > |diffY| && diffX > 50px && pathStack >0 navigateHistory 'backward' (history.back if mobile, else pop current = parent render update direction 'backward'); feedback: if diffX >5 add 'swiping-right' class transform translateX min(diffX-5, innerWidth*0.1)px else remove style; end remove class/style; threshold 5px für early feedback); Copy: Vibration 50ms (navigator.vibrate(50) if 'vibrate' in navigator && isMobile); No Hover (mouseenter deaktiviert, touchstart passive false preventDefault no Zoom/Scroll-Issues); Aria-Updates für Screenreader (post-Copy "Kopiert: title" setTimeout 2000ms reset "Kopiere: title"); Safe-Areas env() für Bottom (Dock padding-bottom calc(4.5rem + env) visible, 12rem expanded; Tab adjust calc + env -1px); Overscroll-y contain; Scrollbar thin rgba(255,255,255,0.15) hover rgba(0,230,255,0.5).
   - **Low-Height (<500px, min-aspect-ratio 1/1)**: Top-Bar min-height 3.5rem; Fixed-Back left 0.6rem padding 0.45rem Icon 20px; Cards padding-top calc(5rem + safe); Dock max-height 4.5rem (expand 12rem adjust body padding-bottom); Tab konsistent 52x36px (Mobil 48x32px).
   - **Allgemein**: Env(safe-area-inset-*) für iOS-Notch (top/left/right/bottom in Top-Bar/Dock/Tab/Modal padding); No-Overlap z-index (Top-Bar 999, Dock 998, Tab 999, Context 2000, Notification 1100, Tooltip 1001, Aurora -1); Reduced-Motion deaktiviert alle (prefers-reduced-motion: reduce → * animation/transition none !important, inkl. jiggle/grain/aurora/view-transitions/Icon-Rotation 180deg).
5. **Debugging & Tools**:
   - **Console**: Errors (JSON.parse catch: console.error "Fehler beim Laden..." + localStorage.removeItem + Reload; fetch !ok throw `HTTP ${status} - ${statusText}` + catch error message in container p red center padding 2rem; Clipboard catch: console.error 'Clipboard error:' err + showNotification 'Fehler beim Kopieren' error).
   - **Breakpoints**: DevTools Elements (z. B. renderFavoritesBar: innerWidth <768 add 'mobile-grid', Initial-Badge textContent charAt(0) uppercase Fallback '?'; copyToClipboard: then/catch branch, setTimeout 1500ms remove copy-success, 2000ms hideTooltip + aria-reset; handleTouchEnd: diffX >50 navigate, threshold 5px; toggleFavoritesBarExpansion: classList.toggle 'is-expanded' auf BEIDE Bar + Controls + body 'favorites-bar-expanded' padding adjust; clearAllFavorites: confirm template-literal length + empty + save + render + clearBtn display='none').
   - **Performance**: Chrome DevTools Performance (RAF throttle no Jank, GPU will-change); Lighthouse (PWA/Perf/A11y Score 95%+); WebPageTest (Load <1s, CoreWebVitals green); Test Copy-Feedback (1.5s Anim + 2s Tooltip/Aria-Reset); FAB-Tab-Animation (Icon-Rotation 180deg 600ms smooth, bottom calc(4.5/12rem + safe -1px) no Gap); Mobile: Vibration mock, Touch-Precision (passive false preventDefault in Favoriten touchstart no Zoom/Scroll).
   - **Edge-Cases**: No-Favorites (Dock hidden, Tab hidden, clearBtn none); Empty Folder (p center padding 2rem opacity 0.7 "Dieser Ordner ist leer."); Long Titles (ellipsis max 70px Desktop/60px Mobil, overflow hidden); 0-Length Title (Initial '?' Badge); Parse-Error (Storage remove + fetch fallback); No View-Transitions (direct callback if !document.startViewTransition); Secure-Context Clipboard (Fallback textarea execCommand if !navigator.clipboard || !isSecureContext).
6. **Deployment & Erweiterung**:
   - **Hosting**: Statisch (GitHub Pages/Netlify/Vercel); HTTPS erforderlich für Clipboard/Vibration.
   - **Erweiterungen**: Service-Worker (sw.js register in initApp für Cache templates.json/CSS/JS offline, z. B. Cache-First-Strategie); Suche: Füge Input in Top-Bar hinzu, on input event filterFavorites (display none if !includes query.toLowerCase() in title); Infinite-Scroll (IntersectionObserver für >36 Items lazy-load); Usage-Tracking (localStorage 'favoriteUsage' {id:count,lastUsed:Date} in copyToClipboard ++ save + sort in renderFavoritesBar by count desc); Export: Download-Button erweitern für CSV/JSON-Export aller Prompts; Themes: Toggle dark/light via CSS-Vars (localStorage 'theme' 'dark'/'light').
   - **Wartung**: Modular (Funktionen isoliert: handleDrag*-Serie, copy*-Chain, toggle*-Serie); Self-Documenting (Params in Vivus/Sortable, clearAllFavorites confirm-template mit length); Tests: Unit (Jest: findNodeById recurse, copy fallback execCommand, clearAllFavorites empty check confirm); E2E (Puppeteer: Swipe diffX50 → back assert, Copy → clipboard assert, Tab-Toggle → Icon-Rotation 180deg assert, Clear → empty favorites assert, Vibration mock); Lint (ESLint no-unused-vars, Stylelint no-invalid-url).
   - **Bekannte Limits**: Max 36 Karten/View (O(n) DOM, erweiterbar Observer); localStorage ~5MB (JSON max ~1000 Prompts, Favoriten-IDs flach); Vivus SVG-only (no Canvas-Fallback); No CDN-Integrity (Vivus/Sortable trust, lokal hostbar); Tab-Button -1px Overlap funktioniert bei konsistenten Bar-Höhen (4.5rem collapsed, 12rem expanded hardcoded in CSS/JS body-class).
   - **Lizenz**: MIT; Abhängigkeiten: Vivus 0.4.6 (https://cdnjs.cloudflare.com/ajax/libs/vivus/0.4.6/vivus.min.js), SortableJS latest (https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js) – Keine Integritäts-Hashes (Sicherheit: CDN-Trust, lokal hostbar für Production).

## 3. Datenstruktur & Zustandsmanagement

### 3.1. JSON-Schema (templates.json & localStorage)
- **Struktur**: Root-Objekt {id: "root" (string), type: "folder" (string), title: string (optional, fallback "Unbenannt"), items: Array (nested, max-depth unbegrenzt)} oder Prompts {id: UUID (generateId() via replace/[xy]/g Math.random*16|0 v= x?r:(r&0x3|0x8) toString16), type: "prompt", title: string, content: string (pre-wrap, word-wrap break-word line 1.75)}. IDs: UUID v4 (xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx, y=(r&0x3|0x8) für RFC-Konformität).
- **Laden**: `loadJsonData(filename)`: const stored = localStorage.getItem('customTemplatesJson'); if stored try JSON.parse → processJson (set jsonData currentNode=root pathStack=[] performViewTransition initial fade-in + history.replaceState {path:[],modalOpen:false} + renderFavoritesBar); catch error console.error "Fehler beim Laden..." + removeItem + loadJsonData fallback fetch(filename) then response.ok? json(): throw HTTP status text + catch error container.innerHTML p red center padding 2rem `Fehler beim Laden der Vorlagen: ${error.message}`; Download/Reset-Visibility: post-processJson downloadBtn/resetBtn display 'inline-flex' (wenn stored) else 'none'.
- **Persistenz**: `persistJsonData(successMsg, type='info')`: try const jsonString = JSON.stringify(jsonData, null, 2) (2 Spaces Indent für Lesbarkeit); localStorage.setItem('customTemplatesJson', jsonString); showNotification(successMsg, type) (create div class notification type + if success clone svgTemplateCheckmark class icon stroke-width 3.2 width/height 19px append + span text msg append + append notificationArea + RAF add 'show' translateY 20px→0 opacity 0→1 + setTimeout 2800ms remove 'show' add 'fade-out' transitionend once if parent remove); catch e console.error "Fehler beim Speichern..." + showNotification 'Speichern fehlgeschlagen!' error.
- **Favoriten**: `favoritePrompts` Array<string> (flach, IDs); `loadFavorites()`: stored = getItem('favoritePrompts') try parse else []; `saveFavorites()`: setItem stringify; Toggle: `toggleFavoriteStatus(promptId)` index = includes? splice index 1 : push + showNotification 'Von Favoriten entfernt'/'Zu Favoriten hinzugefügt' info/success + saveFavorites + updateFavoriteButton (if modal visible && data-id == promptId: starOutline hidden if includes, starFilled hidden !includes + aria-label switch 'Aus/Zu Favoriten'); Clear: `clearAllFavorites()` if length===0 show 'Keine Favoriten vorhanden.' info return; else confirm `Möchten Sie wirklich alle ${favoritePrompts.length} Favoriten löschen? Diese Aktion kann nicht rückgängig gemacht werden.` if true favoritePrompts = [] saveFavorites renderFavoritesBar (hidden + clearBtn display 'none' + body remove 'favorites-bar-visible') show 'Alle Favoriten gelöscht!' success.
- **History**: `window.history` API; `pushState(state={path: Array node.id (pathStack.map n=>n.id + current.id if !=root)}, '', href)` on navigateToNode (if mobile !modal); replaceState {path:[],modalOpen:false} on init/processJson; `onpopstate = handlePopState(event)`: exitOrganizeMode collapseFavoritesBar + state = event.state || {path:[],modalOpen:false} + currentlyModal = modalEl.classList.contains('visible') + direction = state.path.length < pathStack.length ? 'backward' : 'forward' + if currentlyModal && !state.modalOpen closeModal {fromPopstate:true} else if !currentlyModal && state.modalOpen const promptId = state.promptId node = findNodeById(jsonData, promptId) if node && type==='prompt' pathStack = state.path.map id=>findNodeById filter Boolean + if state.path.length>0 && pathStack.length>0 && pathStack[pathStack.length-1].id === promptId pathStack.pop() + currentNode = pathStack.length>0 ? pathStack[pathStack.length-1] : jsonData + openPromptModal(node, true) else handleNavigationFromState(state, direction) else handleNavigationFromState(state, direction); `handleNavigationFromState(state, direction)`: targetPathLength = state.path.length + updateDOM = () => {pathStack = state.path.map id=>findNodeById(jsonData, id) filter Boolean + if pathStack.length !== targetPathLength && state.path.length>0 pathStack = [] else if targetPathLength===0 pathStack = [] + currentNode = targetPathLength===0 ? jsonData : pathStack[pathStack.length-1] + if !currentNode && jsonData currentNode = jsonData + renderView(currentNode) + updateBreadcrumb()} + performViewTransition(updateDOM, direction).
- **Code-Referenzen**: `generateId()` (UUID via replace/[xy]/g Math.random*16|0 v=x?r:(r&0x3|0x8) toString16); `findNodeById(startNode, targetId)` (if !startNode || !targetId return null + if startNode.id===targetId return startNode + if type==='folder' && items for const child of items const found = findNodeById(child, targetId) if found return found); `findParentOfNode(targetId, startNode=jsonData)` (if !startNode.items return null + for const child of items if child.id===targetId return startNode + if child.type==='folder' const found = findParentOfNode(targetId, child) if found return found); `moveNode(sourceId, targetFolderId, newIndex=-1)` (sourceNode = findNodeById(jsonData, sourceId) + targetNode = findNodeById(jsonData, targetFolderId) + if !source || !target || target.type!=='folder' notification 'Verschieben fehlgeschlagen: Ungültiges Ziel.' error return + sourceParent = findParentOfNode(sourceId) + if !sourceParent return + sourceIndex = sourceParent.items.findIndex item=>item.id===sourceId + if sourceIndex>-1 sourceParent.items.splice(sourceIndex, 1) + if !targetNode.items targetNode.items = [] + if newIndex>-1 targetNode.items.splice(newIndex, 0, sourceNode) else push + persistJsonData 'Element verschoben!' success + renderView(currentNode)); `combineIntoNewFolder(sourceId, targetId)` (source = findNodeById sourceId + target = findNodeById targetId + parent = findParentOfNode(sourceId) + if !source || !target || !parent return + newFolder = {id: generateId(), type:'folder', title:'Neuer Ordner', items: [sourceNode, targetNode]} + sourceIndex = parent.items.findIndex item=>item.id===sourceId + targetIndex = parent.items.findIndex item=>item.id===targetId + parent.items = parent.items.filter item=>item.id!==sourceId && item.id!==targetId + insertIndex = Math.min(sourceIndex, targetIndex) + parent.items.splice(insertIndex, 0, newFolder) + persist 'Neuer Ordner erstellt!' success + renderView(currentNode)); `persistJsonData(successMsg, type='info')` (try jsonString = JSON.stringify(jsonData, null, 2) localStorage.setItem('customTemplatesJson', jsonString) showNotification(successMsg, type) downloadBtn/resetBtn display 'inline-flex' catch e console.error "Fehler beim Speichern im Local Storage:" e showNotification 'Speichern fehlgeschlagen!' error); `downloadCustomJson()` (stored = getItem('customTemplatesJson') if !stored notification 'Keine Änderungen...' info return + blob = new Blob([stored], {type:'application/json;charset=utf-8'}) + url = URL.createObjectURL(blob) + a = createElement 'a' href=url download='templates_modified.json' body append click remove revoke); `resetLocalStorage()` (confirm "Möchten Sie wirklich alle lokalen Änderungen verwerfen..." if true removeItem 'customTemplatesJson' 'favoritePrompts' notification 'Änderungen zurückgesetzt. Lade neu...' info + setTimeout 1000ms location.reload()); `loadFavorites()` (stored = getItem('favoritePrompts') if stored try favoritePrompts = JSON.parse(stored) catch e console.error "Fehler beim Laden der Favoriten:" e favoritePrompts = []); `saveFavorites()` (localStorage.setItem('favoritePrompts', JSON.stringify(favoritePrompts))); `toggleFavoriteStatus(promptId)` (if !promptId return + index = favoritePrompts.indexOf(promptId) + if index>-1 splice index 1 show 'Von Favoriten entfernt' info else push show 'Zu Favoriten hinzugefügt' success + saveFavorites + updateFavoriteButton(promptId) + renderFavoritesBar()); `updateFavoriteButton(promptId)` (if !modalEl.classList.contains('visible') || modalEl.dataset.id !== promptId return + isFavorite = favoritePrompts.includes(promptId) + starOutline.classList.toggle('hidden', isFavorite) + starFilled.classList.toggle('hidden', !isFavorite) + modalFavoriteBtn.setAttribute('aria-label', isFavorite ? 'Von Favoriten entfernen' : 'Zu Favoriten hinzufügen')).

## 3. Rendering-Engine & DOM-Manipulation

### 3.1. Karten-Rendering (`renderView(node)` - Zeile 1050-1120)
- **Input**: `node` (Referenz auf aktuellen Ordner-Node aus jsonData).
- **Schritte**:
  1. `exitOrganizeMode()` (if containerEl.classList.contains('edit-mode') toggleOrganizeMode() – entfernt 'edit-mode' class, toggelt organizeBtn.is-active, icons hidden, addBtn display 'inline-flex', sortableInstance.destroy() if exists null).
  2. `const currentScroll = containerEl.scrollTop` (behält Scroll-Position).
  3. `containerEl.innerHTML = ''` (cleart alle Karten).
  4. If !node: `containerEl.innerHTML = '<p style="color:red; text-align:center; padding:2rem;">Interner Fehler: Ungültiger Knoten.</p>'` return.
  5. `const childNodes = node.items || []` (Array von Child-Nodes, fallback []).
  6. `const maxItems = 36` (Limit für Performance, erweiterbar via Observer).
  7. `const nodesToRender = childNodes.slice(0, maxItems)` (begrenzt auf 36).
  8. `const vivusSetups = []` (Array für Vivus-Instanzen), `const renderedCards = []` (Array für Animation-Trigger).
  9. **For-Each-Loop** über nodesToRender (forEach childNode):
     - `const card = document.createElement('div')` + card.classList.add('card').
     - `let nodeId = childNode.id` + if !nodeId nodeId = generateId() childNode.id = nodeId (generiert UUID falls fehlt).
     - card.setAttribute('data-id', nodeId) + setAttribute('data-type', childNode.type) + setAttribute('draggable', 'true').
     - **Delete-Button** (if svgTemplateDelete): createElement 'button' class 'card-delete-btn' aria-label 'Element löschen' data-action 'delete' + appendChild(svgTemplateDelete.cloneNode(true)) + card.appendChild(deleteBtn).
     - **Edit-Button** (if svgTemplateEdit): createElement 'button' class 'card-edit-btn' aria-label 'Element umbenennen' data-action 'edit' + appendChild(svgTemplateEdit.cloneNode(true)) + card.appendChild(editBtn).
     - `const titleElem = document.createElement('h3')` + titleElem.textContent = childNode.title || 'Unbenannt'.
     - `const contentWrapper = document.createElement('div')` + classList.add('card-content-wrapper') + appendChild(titleElem).
     - **Folder-Case** (if childNode.type === 'folder'): card.classList.add('folder-card') + if svgTemplateFolder const folderIconSvg = cloneNode(true) + folderIconId = `icon-folder-${nodeId}` + folderIconSvg.id = folderIconId + contentWrapper.appendChild(folderIconSvg) + vivusSetups.push({parent: card, svgId: folderIconId}) (für Vivus-Animation).
     - **Prompt-Case** (else): card.classList.add('prompt-card') + const btnContainer = createElement('div') classList.add('card-buttons') + if svgTemplateExpand const expandBtn = createElement('button') classList.add('btn', 'btn-ghost') aria-label 'Details anzeigen' data-action 'expand' + appendChild(svgTemplateExpand.cloneNode(true)) + btnContainer.appendChild(expandBtn) + if svgTemplateCopy const copyBtn = createElement('button') classList.add('btn', 'btn-ghost') aria-label 'Prompt kopieren' data-action 'copy' + appendChild(svgTemplateCopy.cloneNode(true)) + btnContainer.appendChild(copyBtn) + contentWrapper.appendChild(btnContainer).
     - card.appendChild(contentWrapper) + containerEl.appendChild(card) + renderedCards.push(card).
  10. **Vivus-Setup** (forEach vivusSetups): if document.body.contains(setup.parent) setupVivusAnimation(setup.parent, setup.svgId) (definiert unten).
  11. If renderedCards.length > 0: containerEl.scrollTop = currentScroll (restore Position) + requestAnimationFrame(() => {renderedCards.forEach(c => {c.classList.add('is-visible') (CSS: opacity 0→1 translateY 20px→0 scale 0.98→1 600ms ease-smooth) + adjustCardTitleFontSize(c) (definiert unten)})}.
  12. Else if childNodes.length === 0 && containerEl.innerHTML === '': containerEl.innerHTML = '<p style="text-align:center; padding:2rem; opacity:0.7;">Dieser Ordner ist leer.</p>' (Fallback-UI).
- **Auswirkungen**: Jede Karte hat opacity 0 transform translateY 20px scale 0.98 (initial hidden), wird via RAF zu opacity 1 translateY 0 scale 1 (600ms); Folder-SVGs animiert via Vivus (delayed 100ms manual, opacity 0→1 on mouseenter 60ms timeout, immediate on touchstart, finish on leave/end/cancel); Title-Font auto-adjust (max 16px min 10px while scrollHeight > clientHeight fontSize -= 0.5px).
- **Code-Referenzen**: `generateId()` (UUID-Generierung); `cloneNode(true)` (deep clone SVGs); `adjustCardTitleFontSize(card)` (Font-Loop); `setupVivusAnimation(parent, svgId)` (Vivus-Instance + Event-Listener: mouseenter !isTouchStarted play(false) timeout 60ms opacity 0→1 reset play; mouseleave !isTouchStarted finish opacity 1; touchstart isTouchStarted=true play(true) passive true; touchend/cancel if isTouchStarted=false finish).

### 3.2. Favoriten-Dock Rendering (`renderFavoritesBar()` - Zeile 1550-1620)
- **Input**: Kein Parameter (global favoritePrompts Array).
- **Schritte**:
  1. `favoritesContainerEl.innerHTML = ''` (cleart Dock).
  2. `collapseFavoritesBar()` (if favoritesBarEl.classList.contains('is-expanded') toggleFavoritesBarExpansion() – entfernt 'is-expanded' von Bar + Controls, body 'favorites-bar-expanded', icon hidden-toggle, aria-expanded false label 'ausklappen').
  3. If favoritePrompts.length === 0: favoritesBarEl.classList.add('hidden') + favoritesControls.classList.add('hidden') + document.body.classList.remove('favorites-bar-visible') + if clearFavoritesBtn clearFavoritesBtn.style.display = 'none' return.
  4. Else: favoritesBarEl.classList.remove('hidden') + favoritesControls.classList.remove('hidden') + document.body.classList.add('favorites-bar-visible') + favoritesExpandToggleBtn.setAttribute('aria-expanded', 'false').
  5. If clearFavoritesBtn clearFavoritesBtn.style.display = 'inline-flex' (sichtbar wenn Favoriten >0).
  6. If window.innerWidth < 768 favoritesContainerEl.classList.add('mobile-grid') else remove (CSS-Trigger: <768 mobile-grid für erweiterte Responsivität, z. B. height 38px padding adjust).
  7. **For-Each-Loop** über favoritePrompts (forEach promptId):
     - const node = findNodeById(jsonData, promptId) (rekursiv sucht in nested items).
     - If node && node.type === 'prompt': const favoriteItem = document.createElement('div') + className = 'favorite-item' + dataset.id = promptId + dataset.type = 'favorite' + setAttribute('aria-label', `Kopiere: ${node.title}`).
     - **Initial-Badge**: const initialBadge = document.createElement('div') + className = 'favorite-item-initial' + const initialLetter = (node.title && node.title.trim().length > 0) ? node.title.trim().charAt(0).toUpperCase() : '?' + initialBadge.textContent = initialLetter (trim() einmal, charAt(0) uppercase Fallback '?').
     - const titleSpan = document.createElement('span') + className = 'favorite-item-title' + titleSpan.textContent = node.title (ellipsis via CSS max-width 70px).
     - const iconWrapper = document.createElement('div') + className = 'favorite-item-icon-wrapper' (relative 20px height, flex center).
     - const copyIcon = svgTemplateFavoriteCopy.cloneNode(true) + classList.add('icon-copy') (absolute 100% width/height, transition transform/opacity 0.3s ease-smooth).
     - const checkmarkIcon = svgTemplateFavoriteCheckmark.cloneNode(true) + classList.add('icon-checkmark') (absolute, scale 0.7 opacity 0 stroke acc-2).
     - iconWrapper.appendChild(copyIcon) + iconWrapper.appendChild(checkmarkIcon).
     - favoriteItem.appendChild(initialBadge) (Grid-Position 1: auto).
     - favoriteItem.appendChild(titleSpan) (Grid-Position 2: 1fr).
     - favoriteItem.appendChild(iconWrapper) (Grid-Position 3: auto justify-self end).
     - favoriteItem.addEventListener('click', () => copyToClipboard(node.content, favoriteItem, node)) (definiert unten).
     - favoriteItem.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false }) (verhindert Zoom/Scroll bei Touch, passive false für Präzision).
     - favoriteItem.addEventListener('mouseenter', (e) => showFavoriteTooltip(e.currentTarget, node)) (50ms delay, definiert unten).
     - favoriteItem.addEventListener('mouseleave', () => hideFavoriteTooltip()) (clearTimeout).
     - favoritesContainerEl.appendChild(favoriteItem).
  8. setTimeout(() => {const isOverflowing = favoritesContainerEl.scrollWidth > favoritesContainerEl.clientWidth; favoritesContainerEl.classList.toggle('is-scrollable', isOverflowing)}, 0) (0ms Timeout für DOM-Flush, toggelt CSS-Mask-Gradient: linear-gradient(to right, transparent 0, black 10px, black calc(100% - 40px), transparent 100%) für Fade-Out bei Scroll-Overflow).
- **Auswirkungen**: Dock zeigt horizontal (Desktop: 6-8 Items sichtbar, scroll-snap x mandatory) oder grid (Expand: auto-fit minmax(140px,1fr) gap 0.8rem vertical auto); Badge (28px circle, background per CSS :nth-child(8n+x) match zu Item-Border, text uppercase Letter, shadow 0 2px 8px) + Title (ellipsis 70px font 0.85rem) + Icon (20px, copy default opacity 1 scale 1, success: opacity 0 scale 0.7 + checkmark opacity 1 scale 1 anim checkmark-pop 0.4s bounce 0.7→1.1→1); Hover: background rgba(255,255,255,0.12) translateY -2px color fg-1 brightness 1.2; Active: scale 0.97 translateY -1px; Copy: class 'copy-success' 600ms filter drop-shadow 0 0 8px acc-2 scale 1→1.15 at 30% (organisch, kein rechteckiger Kasten via box-shadow).
- **Code-Referenzen**: `findNodeById(jsonData, promptId)` (rekursiv: if id-match return, else for child of items recurse); `cloneNode(true)` (deep clone SVGs); `showFavoriteTooltip(targetElement, node)` (clearTimeout tooltipTimeout + setTimeout 50ms if !favoriteTooltipEl return + innerHTML='' + strong class 'favorite-tooltip-title' text node.title + textNode = document.createTextNode((node.content || '').substring(0,200) + (length>200 ? '...' : '')) append + append tooltipContent + targetRect = targetElement.getBoundingClientRect() margin=10 + visibility hidden add visible offsetWidth/Height remove visible '' + top = rect.top - height - margin left = rect.left + width/2 - width/2 clamp if left<margin left=margin if left+width>innerWidth-margin left=innerWidth-width-margin if top<margin top=rect.bottom+margin + style top/left + requestAnimationFrame add visible); `hideFavoriteTooltip()` (clearTimeout + if favoriteTooltipEl classList.remove('visible')).

### 3.3. Floating Tab-Control (`toggleFavoritesBarExpansion()` - Zeile 1576-1590)
- **Input**: Kein Parameter (global favoritesBarEl, favoritesControls, favoritesExpandToggleBtn).
- **Schritte**:
  1. const isExpanded = favoritesBarEl.classList.toggle('is-expanded') (toggelt max-height 4.5rem → 12rem, transform translateY 0 via CSS transition 600ms ease-smooth).
  2. favoritesControls.classList.toggle('is-expanded', isExpanded) (toggelt bottom calc(4.5rem + safe -1px) → calc(12rem + safe -1px), transition 600ms smooth für nahtlose Bewegung).
  3. document.body.classList.toggle('favorites-bar-expanded', isExpanded) (adjustiert cards-container padding-bottom 4.5rem → 12rem, notification-area bottom 5rem → 12.5rem).
  4. const expandIcon = favoritesExpandToggleBtn.querySelector('.icon-expand') + const collapseIcon = favoritesExpandToggleBtn.querySelector('.icon-collapse').
  5. expandIcon.classList.toggle('hidden', isExpanded) + collapseIcon.classList.toggle('hidden', !isExpanded) (wechselt SVG: Pfeil oben collapsed → unten expanded).
  6. favoritesExpandToggleBtn.setAttribute('aria-expanded', isExpanded) + setAttribute('aria-label', isExpanded ? 'Favoritenleiste einklappen' : 'Favoritenleiste ausklappen') (Accessibility).
- **Auswirkungen**: Synchrone State-Änderung (Bar max-height + Controls bottom + Body padding); Icon-Rotation via CSS `.favorites-controls.is-expanded #favorites-expand-toggle .icon {transform: rotate(180deg) 600ms ease-smooth}` (automatisch auf .icon angewendet); Hover auf Tab: translateY -2px shadow increase (0 -8px 20px rgba(0,0,0,0.3) + 0 -3px 12px rgba(0,230,255,0.25)), background rgba(28,32,46,0.85); Active: translateY 0; Kein Gap (bottom -1px für Border-Overlap mit Bar).
- **Code-Referenzen**: `collapseFavoritesBar()` (if favoritesBarEl.classList.contains('is-expanded') toggleFavoritesBarExpansion() – ruft toggle auf, um zu kollabieren); Aufgerufen in navigateToNode/exitOrganizeMode/handleKeyDown (Escape) für Auto-Collapse.

## 4. Interaktionen, Animationen & Effekte

### 4.1. Primäre Interaktionen
- **Karten-Interaktionen** (`handleCardContainerClick(e)` - Zeile 1150-1200): If modalEl.visible || e.target.closest('.modal-content') return; const card = e.target.closest('.card') + if !card if e.target === containerEl && pathStack.length >0 navigateOneLevelUp() return; const button = e.target.closest('button[data-action]') + if containerEl.classList.contains('edit-mode') if button const action = button.getAttribute('data-action') const id = card.getAttribute('data-id') if action === 'delete' handleDeleteClick(id, card) (confirm `Möchten Sie "${nodeToDelete.title}" wirklich löschen?` if true card.style.transition 'opacity 0.3s ease, transform 0.3s ease' opacity 0 transform scale 0.8 + setTimeout 300ms parent = findParentOfNode(id) if parent.items index = findIndex item.id===id splice index 1 + if favoritePrompts.includes(id) favoritePrompts.filter favId!==id saveFavorites renderFavoritesBar + persistJsonData 'Element gelöscht!' success + renderView(currentNode) updateBreadcrumb) else if action === 'edit' startRenamingCard(card) (titleElement = query 'h3' originalText = textContent + input = createElement 'input' type text value original class 'rename-input' titleElement.style.display = 'none' parent.insertBefore input titleElement + input.focus() select + blur/keydown Enter finishRename = () => {newTitle = trim if newTitle && !==original id = card.data-id node = findNodeById(jsonData, id) if node node.title = newTitle titleElement.textContent = newTitle persist 'Umbenennung gespeichert!' success + if favoritePrompts.includes(id) renderFavoritesBar + exitRenameMode(card) (input = query '.rename-input' titleElement = query 'h3' if input && titleElement input.remove() titleElement.style.display = 'block' adjustCardTitleFontSize(card))} + input.addEventListener('blur', finishRename) + input.addEventListener('keydown', e => if e.key==='Enter' finishRename()) return; const id = card.getAttribute('data-id') node = findNodeById(jsonData, id) if !node return; if button e.stopPropagation() action = button.data-action if action === 'expand' openPromptModal(node) (if node modalEl.setAttribute('data-id', node.id) promptFullTextEl.value = node.content || '' updateFavoriteButton(node.id) requestAnimationFrame adjustTextareaHeight(promptFullTextEl) openModal(modalEl) if isMobile() && !calledFromPopstate && node const currentState = window.history.state || {path:[],modalOpen:false} if !currentState.modalOpen const currentViewPathIds = pathStack.map n=>n.id window.history.pushState({path: currentViewPathIds, modalOpen: true, promptId: node.id}, '', window.location.href)) else if action === 'copy' copyPromptTextForCard(node, e.target.closest('button')) (copyToClipboard(node.content || '', buttonElement) definiert unten) else if node.type === 'folder' navigateToNode(node) (exitOrganizeMode collapseFavoritesBar performViewTransition if currentNode !== node pathStack.push(currentNode) currentNode = node renderView(currentNode) updateBreadcrumb forward slide-from-right if isMobile() && !modalEl.classList.contains('visible') let historyPath = pathStack.map n=>n.id if currentNode && currentNode !== jsonData historyPath.push(currentNode.id) window.history.pushState({path: historyPath, modalOpen: false}, '', window.location.href)) else if node.type === 'prompt' openPromptModal(node).
- **Drag-and-Drop** (`handleDragStart/Over/Enter/Leave/Drop/End` - Zeile 1220-1300): If !containerEl.classList.contains('edit-mode') || !e.target.closest('.card') e.preventDefault() return; card = closest('.card') dragSource = card e.dataTransfer.setData('text/plain', card.getAttribute('data-id')) effectAllowed = 'move' setTimeout 0 card.classList.add('dragging') (CSS: cursor grabbing opacity 0.85 scale 1.05 shadow-1 z999 no anim); Over: if !edit return e.preventDefault() dropEffect = 'move'; Enter: if !edit return e.preventDefault() targetCard = closest('.card') if targetCard && !==dragSource clearTimeout(springLoadTimeout) dragTarget = targetCard targetType = data-type if targetType === 'folder' targetCard.classList.add('drop-target-folder') (CSS: transform scale 1.05 border 2px solid acc-2 box-shadow 0 0 15px 5px rgba(0,230,255,0.24)) springLoadTimeout = setTimeout(() => {nodeId = data-id node = findNodeById(jsonData, nodeId) if node navigateToNode(node)}, 800) else targetCard.classList.add('drop-target-combine') (CSS: border 2px dashed acc-2 background rgba(0,230,255,0.12)); Leave: if !edit return targetCard = closest('.card') if targetCard clearTimeout(springLoadTimeout) targetCard.classList.remove('drop-target-folder', 'drop-target-combine') if dragTarget === targetCard dragTarget = null; Drop: if !edit return e.preventDefault() clearTimeout(springLoadTimeout) droppedOnCard = closest('.card') sourceId = dataTransfer.getData('text/plain') if !sourceId return sourceNode = findNodeById(jsonData, sourceId) if !sourceNode return if droppedOnCard && !==dragSource targetId = droppedOnCard.data-id targetNode = findNodeById(jsonData, targetId) if !targetNode return if targetNode.type === 'folder' moveNode(sourceId, targetNode.id) (sourceNode = findNodeById sourceId targetFolderNode = findNodeById targetFolderId if !source || !target || target.type!=='folder' notification 'Verschieben fehlgeschlagen: Ungültiges Ziel.' error return sourceParent = findParentOfNode(sourceId) if !sourceParent return sourceIndex = sourceParent.items.findIndex item=>item.id===sourceId if sourceIndex > -1 sourceParent.items.splice(sourceIndex, 1) if !targetFolderNode.items targetFolderNode.items = [] if newIndex > -1 targetFolderNode.items.splice(newIndex, 0, sourceNode) else targetFolderNode.items.push(sourceNode) persistJsonData 'Element verschoben!' success renderView(currentNode)) else if confirm(`Möchten Sie "${sourceNode.title}" und "${targetNode.title}" in einem neuen Ordner zusammenfassen?`) combineIntoNewFolder(sourceId, targetId) (sourceNode = findNodeById sourceId targetNode = findNodeById targetId parentNode = findParentOfNode(sourceId) if !source || !target || !parent return newFolder = {id: generateId(), type: 'folder', title: 'Neuer Ordner', items: [sourceNode, targetNode]} sourceIndex = parentNode.items.findIndex item=>item.id===sourceId targetIndex = parentNode.items.findIndex item=>item.id===targetId parentNode.items = parentNode.items.filter item=>item.id!==sourceId && item.id!==targetId insertIndex = Math.min(sourceIndex, targetIndex) parentNode.items.splice(insertIndex, 0, newFolder) persistJsonData 'Neuer Ordner erstellt!' success renderView(currentNode)); If dragSource dragSource.classList.remove('dragging') querySelectorAll('.drop-target-folder, .drop-target-combine').forEach el=>el.classList.remove(...) dragSource = null dragTarget = null; End: clearTimeout(springLoadTimeout) if dragSource dragSource.classList.remove('dragging') querySelectorAll('.drop-target-folder, .drop-target-combine').forEach el=>el.classList.remove(...) dragSource = null dragTarget = null.
- **Kontextmenü** (`handleContextMenu(e)` - Zeile 1300-1310): If modalEl.classList.contains('visible') || containerEl.classList.contains('edit-mode') return; targetElement = e.target.closest('.card, .favorite-item') if !targetElement return e.preventDefault() showContextMenu(e.pageX, e.pageY, targetElement) (definiert unten).
- **Tooltip** (`showFavoriteTooltip(targetElement, node)` - Zeile 1400-1450): clearTimeout(tooltipTimeout) tooltipTimeout = setTimeout(() => {if !favoriteTooltipEl return favoriteTooltipEl.innerHTML = '' const tooltipTitle = document.createElement('strong') className = 'favorite-tooltip-title' textContent = node.title const tooltipContent = document.createTextNode((node.content || '').substring(0,200) + ((node.content || '').length > 200 ? '...' : '')) favoriteTooltipEl.appendChild(tooltipTitle) favoriteTooltipEl.appendChild(tooltipContent) targetRect = targetElement.getBoundingClientRect() viewportMargin = 10 favoriteTooltipEl.style.visibility = 'hidden' favoriteTooltipEl.classList.add('visible') tooltipWidth = offsetWidth tooltipHeight = offsetHeight favoriteTooltipEl.classList.remove('visible') favoriteTooltipEl.style.visibility = '' let top = targetRect.top - tooltipHeight - viewportMargin let left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2) if left < viewportMargin left = viewportMargin if left + tooltipWidth > window.innerWidth - viewportMargin left = window.innerWidth - tooltipWidth - viewportMargin if top < viewportMargin top = targetRect.bottom + viewportMargin favoriteTooltipEl.style.top = `${top}px` favoriteTooltipEl.style.left = `${left}px` requestAnimationFrame(() => favoriteTooltipEl.classList.add('visible'))}, 50); `hideFavoriteTooltip()` (clearTimeout(tooltipTimeout) if favoriteTooltipEl favoriteTooltipEl.classList.remove('visible')).
- **Notifications** (`showNotification(message, type='info')` - Zeile 1450-1480): if notificationTimeoutId const existing = notificationAreaEl.querySelector('.notification') if existing existing.remove() clearTimeout(notificationTimeoutId) const notificationEl = document.createElement('div') classList.add('notification', type) if type === 'success' && svgTemplateCheckmark const icon = cloneNode(true) classList.add('icon') notificationEl.appendChild(icon) const textNode = document.createElement('span') textNode.textContent = message notificationEl.appendChild(textNode) notificationAreaEl.appendChild(notificationEl) requestAnimationFrame(() => notificationEl.classList.add('show')) notificationTimeoutId = setTimeout(() => {notificationEl.classList.remove('show') notificationEl.classList.add('fade-out') notificationEl.addEventListener('transitionend', () => {if notificationEl.parentNode === notificationAreaEl notificationEl.remove()}, {once: true}) notificationTimeoutId = null}, 2800).
- **Modal-Workflows**: `openModal(element)` (element.classList.remove('hidden') requestAnimationFrame(() => requestAnimationFrame(() => element.classList.add('visible'))) updateBreadcrumb()); `closeModal(elementOrOptions={})` (let element = modalEl calledFromPopstate = !!elementOrOptions.fromPopstate fromBackdrop = !!elementOrOptions.fromBackdrop if elementOrOptions.nodeType === 1 element = elementOrOptions else if typeof elementOrOptions === 'object' && elementOrOptions !== null calledFromPopstate = !!elementOrOptions.fromPopstate fromBackdrop = !!elementOrOptions.fromBackdrop if !element.classList.contains('visible') return if element === modalEl && promptFullTextEl.classList.contains('is-editing') toggleEditMode(false) element.classList.remove('visible') setTimeout(() => {element.classList.add('hidden') if element === modalEl element.removeAttribute('data-id') element.removeAttribute('data-mode') promptTitleInputEl.style.display = 'none' promptFullTextEl.style.height = 'auto'}, currentTransitionDurationMediumMs = 300) if element === modalEl if fromBackdrop if isMobile() && window.history.state?.modalOpen && !calledFromPopstate window.history.back() updateBreadcrumb else if isMobile() && !calledFromPopstate && window.history.state?.modalOpen window.history.back() else updateBreadcrumb); `toggleEditMode(isEditing)` (promptFullTextEl.classList.toggle('is-editing', isEditing) promptFullTextEl.readOnly = !isEditing modalEditBtn.classList.toggle('hidden', isEditing) modalSaveBtn.classList.toggle('hidden', !isEditing) copyModalButton.classList.toggle('hidden', isEditing) modalCloseBtn.classList.toggle('hidden', isEditing) modalFavoriteBtn.classList.toggle('hidden', isEditing) const isNewMode = modalEl.dataset.mode === 'new' promptTitleInputEl.style.display = isEditing && isNewMode ? 'block' : 'none' if isEditing if !isNewMode promptFullTextEl.focus() const textLength = promptFullTextEl.value.length promptFullTextEl.setSelectionRange(textLength, textLength) adjustTextareaHeight(promptFullTextEl)); `savePromptChanges()` (const mode = modalEl.dataset.mode if mode === 'new' const title = promptTitleInputEl.value.trim() if !title showNotification 'Der Titel darf nicht leer sein.' error promptTitleInputEl.focus() return const newPromptNode = {id: generateId(), type: 'prompt', title: title, content: promptFullTextEl.value} if !currentNode.items currentNode.items = [] currentNode.items.push(newPromptNode) persistJsonData 'Prompt hinzugefügt!' success renderView(currentNode) closeModal() else const id = modalEl.getAttribute('data-id') if !id || !jsonData return const nodeToUpdate = findNodeById(jsonData, id) if nodeToUpdate const newText = promptFullTextEl.value nodeToUpdate.content = newText persistJsonData 'Prompt gespeichert!' success toggleEditMode(false)); `saveNewFolder()` (const title = folderTitleInputEl.value.trim() if !title showNotification 'Der Titel darf nicht leer sein.' error folderTitleInputEl.focus() return const newFolderNode = {id: generateId(), type: 'folder', title: title, items: []} if !currentNode.items currentNode.items = [] currentNode.items.push(newFolderNode) persistJsonData 'Ordner hinzugefügt!' success renderView(currentNode) closeModal(createFolderModalEl)); `openNewPromptModal()` (exitOrganizeMode modalEl.dataset.mode = 'new' promptTitleInputEl.value = '' promptFullTextEl.value = '' promptTitleInputEl.style.display = 'block' openModal(modalEl) toggleEditMode(true) promptTitleInputEl.focus()); `openPromptModal(node, calledFromPopstate = false)` (if node modalEl.setAttribute('data-id', node.id) promptFullTextEl.value = node.content || '' updateFavoriteButton(node.id) requestAnimationFrame(() => adjustTextareaHeight(promptFullTextEl)) openModal(modalEl) if isMobile() && !calledFromPopstate && node const currentState = window.history.state || {path: [], modalOpen: false} if !currentState.modalOpen const currentViewPathIds = pathStack.map(n => n.id) window.history.pushState({path: currentViewPathIds, modalOpen: true, promptId: node.id}, '', window.location.href)); `openCreateFolderModal()` (folderTitleInputEl.value = '' openModal(createFolderModalEl) folderTitleInputEl.focus()); `openMoveItemModal(itemId)` (moveItemModalEl.dataset.itemId = itemId renderFolderTree(itemId) openModal(moveItemModalEl)); `renderFolderTree(itemIdToMove)` (moveItemFolderTreeEl.innerHTML = '' const createTree = (node, parentElement, level = 0) => {if node.type !== 'folder' return const item = document.createElement('div') item.classList.add('folder-tree-item') item.dataset.folderId = node.id item.style.paddingLeft = `${0.8 + level * 1.5}rem` const icon = svgTemplateFolder.cloneNode(true) icon.style.width = '20px' icon.style.height = '20px' icon.style.flexShrink = '0' item.appendChild(icon) const name = document.createElement('span') name.textContent = node.title item.appendChild(name) const parentOfItemToMove = findParentOfNode(itemIdToMove) if node.id === itemIdToMove || node.id === parentOfItemToMove?.id item.classList.add('disabled') else item.addEventListener('click', () => {const selected = moveItemFolderTreeEl.querySelector('.selected') if selected selected.classList.remove('selected') item.classList.add('selected') moveItemConfirmBtn.disabled = false}) parentElement.appendChild(item) if node.items node.items.forEach(child => createTree(child, parentElement, level + 1))} createTree(jsonData, moveItemFolderTreeEl)); `confirmMoveItem()` (const itemId = moveItemModalEl.dataset.itemId const selectedFolderEl = moveItemFolderTreeEl.querySelector('.selected') if !itemId || !selectedFolderEl return const targetFolderId = selectedFolderEl.dataset.folderId moveNode(itemId, targetFolderId) closeModal(moveItemModalEl)).

### 4.2. Animationen & Effekte (GPU-beschleunigt, will-change transform/opacity/filter)
- **Aurora-Parallax** (`updateParallax()` - Zeile 800): Aufgerufen in containerEl.addEventListener('scroll', () => {lastScrollY = scrollTop if !ticking window.requestAnimationFrame(() => {updateParallax() ticking = false}) ticking = true}) – const parallaxFactor = 0.3 auroraContainerEl.style.transform = `translateY(${lastScrollY * parallaxFactor}px)` (3 Shapes absolute vmax-radius blur 100px opacity 0.15 mix-blend-mode plus-lighter, animiert via @keyframes aurora-anim-1/2/3 translate/scale alternate 30/40/50s ease-in-out).
- **Karten-Entry** (in renderView RAF): renderedCards.forEach(c => c.classList.add('is-visible')) – CSS: .card opacity 0 transform translateY 20px scale 0.98 → opacity 1 translateY 0 scale 1 600ms ease-smooth (transition transform/opacity).
- **Edit-Mode Jiggle** (toggleOrganizeMode): .cards-container.edit-mode .card {cursor: grab animation: jiggle 0.4s infinite} @keyframes jiggle {0% transform rotate(-0.5deg) translateY(0px) 50% rotate(0.5deg) translateY(-1px) 100% rotate(-0.5deg) translateY(0px)} (alle Karten wackeln bei edit-mode).
- **Hover-Effekte**: .card:hover {transform: translateY(-5px) scale(1.03) box-shadow vignette + 0 16px 40px rgba(0,0,0,0.5) border-color glass-stroke-hover z-index 10 transition 0.26s ease-smooth} (Lift + Glow); .favorite-item:hover {background rgba(255,255,255,0.12) transform translateY -2px color fg-1 filter brightness(1.2) transition 0.26s}; #favorites-expand-toggle:hover {transform translateY -2px box-shadow 0 -8px 20px rgba(0,0,0,0.3) 0 -3px 12px rgba(0,230,255,0.25) background rgba(28,32,46,0.85) ::before opacity .6→.85 transition 0.3s}.
- **Copy-Success-Animation** (in copyToClipboard showSuccess setTimeout 1500ms remove): targetElement.classList.add('copy-success') – CSS: .icon-copy.copy-success {animation: copy-success-anim 600ms ease-smooth} @keyframes copy-success-anim {0% transform scale(1) filter drop-shadow(0 0 0 transparent) 30% scale(1.15) filter drop-shadow(0 0 8px var(--acc-2)) 100% scale(1) filter drop-shadow(0 0 0 transparent)} (organischer Glow ohne rechteckigen Kasten, da filter drop-shadow statt box-shadow).
- **Checkmark-Pop** (in copyToClipboard showSuccess): .favorite-item.copy-success .icon-checkmark {transform scale(1) opacity 1 animation checkmark-pop 0.4s bounce} @keyframes checkmark-pop {0% scale(0.7) 70% scale(1.1) 100% scale(1)} (checkmark erscheint mit Bounce).
- **View-Transitions** (performViewTransition updateDomFunction direction): if !document.startViewTransition updateDomFunction() return document.documentElement.dataset.pageTransitionDirection = direction const transition = document.startViewTransition(updateDomFunction) transition.finished.finally(() => delete document.documentElement.dataset.pageTransitionDirection) – CSS: ::view-transition-old/new(root) {animation-duration var(--transition-duration-page) 0.35s animation-timing-function ease-smooth width/height 100%} forward: old slide-to-left (translateX 0→-35px opacity 1→0) new slide-from-right (translateX 35px→0 opacity 0→1); backward: old slide-to-right (0→35px 1→0) new from-left (-35px→0 0→1); initial/other: old fade-out (opacity 1→0) new fade-in (delay 0.1*duration opacity 0→1).
- **Modal-Transitions**: openModal remove hidden + RAF(RAF add visible backdrop-filter blur 0→16px opacity 0→1 visibility hidden→visible transition 0.26s); closeModal remove visible + setTimeout 300ms add hidden (modal-content scale 0.95→1 opacity 0→1 transition 0.6s).
- **Notification-Transitions**: show add 'show' translateY 20px→0 opacity 0→1 0.26s; fade-out remove 'show' add 'fade-out' translateY 0→20px opacity 1→0 0.26s transitionend remove if parent.
- **Tooltip-Transitions**: showFavoriteTooltip setTimeout 50ms visibility hidden add visible offsetWidth/Height measure remove visible '' + style top/left + RAF add visible (translateY 10px→0 opacity 0→0.95 0.2s); hideFavoriteTooltip remove visible (opacity 0.95→0 visibility visible→hidden 0.2s, visibility 0s 0.2s delay).
- **Body-Grain**: @keyframes grain from translate(0,0) 50% translate(-1%,1%) to translate(0,0) 7s steps(10) infinite (Body::before content '' fixed inset 0 background SVG-noise opacity 0.3 pointer-none mix-blend-mode soft-light).
- **Code-Referenzen**: Alle via RAF (requestAnimationFrame) für 60fps; Throttling in scroll (ticking = true/false window.requestAnimationFrame updateParallax ticking = false); Reduced-Motion: @media (prefers-reduced-motion: reduce) {*,*::before,*::after {animation: none !important; transition: none !important}} (deaktiviert jiggle, grain, aurora, view-transitions, icon-rotation, copy-anim, etc.).

## 5. Responsivität & Viewport-spezifisches Verhalten

### 5.1. Desktop (>1024px)
- **Layout**: Karten-Grid display grid template-columns repeat(auto-fit, minmax(120px, 1fr)) gap clamp(0.8rem, 2vw, 1.5rem) padding clamp(0.8rem, 2.5vw, 1.8rem) top calc(6rem + safe-top) bottom calc(6.5rem + safe-bottom) max-width calc(6*140px + 5*1.5rem + 2*clamp(0.8rem,2.5vw,1.8rem)) margin 0 auto (5-6 Spalten bei 120px min, auto-fit passt sich Container an); Top-Bar fixed top safe-top left/right safe-left/right padding 0.6rem 1.2rem min-height 3.75rem gap 0.5rem (Breadcrumb flex-grow 1 center nowrap overflow-x auto no-scrollbar, Buttons inline-flex: Back, Add, Download/Reset if stored, Clear-Favorites if favoritePrompts.length >0, Fullscreen, Logo); Favoriten-Dock fixed bottom safe-bottom left/right safe-left/right max-height 4.5rem (horizontal flex gap 0.6rem align center padding 0.75rem safe-left/right overflow-x auto scrollbar none scroll-snap-type x mandatory, Items flex-shrink 0 basis/min-width 130px height 42px padding 0 0.8rem 0 0.5rem font 0.9rem weight 500, Initial-Badge 28px circle, Title 70px ellipsis font 0.85rem, Icon-Wrapper 20px); Floating Tab fixed right calc(1rem + safe-right) bottom calc(4.5rem + safe-bottom - 1px) (collapsed, 52x36px border-radius 12px 12px 0 0 glassmorphism rgba(28,32,46,0.75) backdrop-blur 20px saturate 180% border 1px glass-stroke border-bottom none shadow 0 -6px 16px rgba(0,0,0,0.25) 0 -2px 8px rgba(0,230,255,0.15) ::before gradient 180deg acc-2→acc-1 opacity 0.6 hover 0.85 ::after noise 0.2, Icon 22px Pfeil oben); Notification fixed bottom calc(1.2rem + safe-bottom) left 50% translateX -50% z 1100 flex column gap 0.6rem (adjust bei favorites-visible 5rem, expanded 12.5rem); Modal fixed inset 0 padding safe-areas background rgba(0,0,0,0.5) backdrop-blur 0→16px opacity 0→1 visibility hidden→visible transition 0.26s, content max-width 750px width 92% max-height 88vh overflow-y auto flex column transform scale 0.95→1 opacity 0→1 0.6s, small-modal max-width 450px padding 1.5rem.
- **Interaktionen**: Hover aktiviert (Karten lift translateY -5px scale 1.03 shadow + border acc-2 z10 0.26s, Favoriten background 0.12 translateY -2px brightness 1.2, Tab translateY -2px shadow increase background 0.85 ::before 0.85); Klicks instant (cursor pointer -webkit-tap-highlight transparent); Tooltip on mouseenter 50ms delay (position top/left collision margin 10px, visibility hidden→visible RAF, max-width 320px line 1.5 white-space pre-wrap text-align left, ::before gradient-border opacity 0.8 ::after noise 0.25); Scroll: Parallax stark (Aurora translateY *0.3, ticking throttle RAF); Edit: Jiggle infinite 0.4s rotate/translateY; Drag: Visual feedback (ghost opacity 0.7 dashed acc-2 bg 0.12, target-folder scale 1.05 ring shadow 0 0 15px acc-2 0.24, target-combine dashed bg 0.12); Copy: Notification success Checkmark-SVG clone stroke acc-2 width/height 19px + 1.5s copy-success filter drop-shadow scale 1→1.15 at 30% + 2s Tooltip + aria "Kopiert: title" reset "Kopiere: title" + Vibration 50ms if mobile.
- **Animationen**: View-Transitions forward slide-to-left/old from-right/new 0.35s, backward to-right/old from-left/new; Fade-in/out initial/other delay 0.1*duration; Grain body::before translate -1%1% 7s steps 10 infinite soft-light 0.3 opacity.

### 5.2. Tablet (768-1024px)
- **Layout**: Karten-Grid 3-4 Spalten gap 1.2rem padding 1.5rem; Top-Bar kompakt gap 0.5rem (Breadcrumb margin 0 0.6rem, Buttons flex space-between); Favoriten-Dock horizontal flex 4-6 Items (basis/min-width 130px height 42px font 0.9rem, no 'mobile-grid' da innerWidth >=768); Expand: Grid repeat(auto-fit, minmax(140px,1fr)) gap 0.8rem vertical auto padding-right 1.5rem (2 Spalten bei 768px, 3 bei 1024px); Floating Tab konsistent 52x36px right 1rem bottom calc(4.5/12rem + safe -1px); Notification bottom calc(5rem + safe) bei visible, 12.5rem expanded; Modal width 92% max-height 88vh (landscape: center, portrait: bottom-heavy).
- **Interaktionen**: Hover/Touch-Hybrid (Mouse: lift/hover-glow; Touch: passive true für Swipe, false für Favoriten-Klick preventDefault no Zoom); Breadcrumb overflow-auto no-scrollbar (horizontal scroll bei langen Pfaden); Add-Menü absolute top calc(100% + 8px) right 0 scale 0.95 translateY -10px→1 opacity 0→1 pointer-none flex column gap 0.3rem (hover items background 0.1 color acc-2); Drag: Gleiche Feedback wie Desktop, aber Touch-Start passive true (smooth move).
- **Animationen**: Gleiche wie Desktop, aber reduzierte Schatten (z. B. Card hover shadow 0 16px 40px 0.5 opacity statt intensiver); Parallax moderat (Aurora *0.3, aber bei Tablet-Scroll weniger sichtbar).

### 5.3. Mobile (<768px, speziell <420px)
- **Layout**: Karten-Grid repeat(3, 1fr) gap 0.6rem padding 0.6rem top calc(5.5rem + safe-top) (3 Spalten bei <420px, auto-fit bei 421-767px); Top-Bar min-height 3.5rem padding 0.6rem (Icons 20px, gap 0.5rem, Clear-Favorites inline-flex wenn length>0); Fixed-Back fixed left calc(1.2rem + safe-left) top 50% translateY -50% padding 0.7rem z 900 (hidden if pathStack.length===0 && currentNode === jsonData, visible sonst, hover scale 1.12 shadow-1); Favoriten-Dock: innerWidth <768 → classList.add('mobile-grid') (CSS: height 38px padding 0 0.6rem 0 0.4rem gap 0.4rem flex-basis/min-width 110px font 0.85rem, Initial-Badge 24px font 0.85rem, Title max 60px font 0.8rem, Icon 18px); Horizontal flex 3-4 Items (scroll-snap x mandatory mask gradient transparent 0 black 10px black calc(100%-40px) transparent 100%); Expand: grid-template-columns 1fr (full-width vertical stack overflow-y auto padding-right 1.5rem, align-content flex-start); Floating Tab fixed right calc(0.75rem + safe-right) bottom calc(4.5rem + safe-bottom -1px) collapsed, calc(12rem + safe-bottom -1px) expanded (48x32px, border-radius 12px 12px 0 0 glassmorphism rgba 0.75 backdrop-blur, shadow 0 -6px, hover translateY -2px); Notification fixed bottom calc(1.2rem + safe-bottom) left 50% translateX -50% (adjust bei visible 5rem, expanded 12.5rem, z 1100 flex column gap 0.6rem pointer-none transition bottom 600ms).
- **Interaktionen**: Touch-fokussiert (kein Hover, mouseenter deaktiviert); Swipe-Back: containerEl.addEventListener('touchstart', handleTouchStart passive true) X/Y = touches[0].clientX/Y end = X/Y; 'touchmove' passive true endX/Y = touches[0] diffX = endX - startX if |diffX| > |diffY| && diffX > swipeFeedbackThreshold 5 add 'swiping-right' class transform translateX min(diffX -5, window.innerWidth * 0.1)px (visual feedback) else remove class/style ''; 'touchend' passive true remove 'swiping-right' style '' if |diffX| > |diffY| && diffX > swipeThreshold 50 if pathStack.length >0 navigateHistory('backward') (if isMobile() window.history.back() else if !isMobile() && pathStack.length >0 exitOrganizeMode performViewTransition pop current = parent render update direction 'backward'); Favoriten-Klick: addEventListener('touchstart', e => e.preventDefault() passive false) (verhindert Zoom/Scroll bei Touch, ermöglicht präzise Klick-Registrierung); Copy: if 'vibrate' in navigator && isMobile() navigator.vibrate(50) (haptisches Feedback); Modal: openPromptModal if mobile !calledFromPopstate && node history.pushState {path: pathStack.map n=>n.id, modalOpen: true, promptId: node.id} (state für popstate reopen); Close on backdrop click: if e.target === modalEl e.stopPropagation() closeModal({fromBackdrop: true}) (if fromBackdrop && isMobile() && history.state?.modalOpen && !fromPopstate history.back() updateBreadcrumb).
- **Animationen**: Reduziert (z. B. Card hover lift deaktiviert, aber active scale 0.97 translateY -1px; Tab hover translateY -2px shadow increase, aber touchstart passive false für no Delay); View-Transitions gleiche wie Desktop (slide/fade 0.35s); Copy-Animation filter drop-shadow (kein Kasten, da drop-shadow statt box-shadow); Icon-Rotation 180deg 600ms smooth (via CSS .is-expanded, JS toggle hidden auf expand/collapse SVGs); Notification translateY 20px→0 opacity 0→1 0.26s (bottom adjust bei dock visible/expanded).
- **Edge-Cases**: Safe-Areas env() (bottom calc(4.5rem + env(safe-area-inset-bottom)) visible, 12rem expanded; Tab bottom calc + env -1px für Overlap; Modal padding env(safe-*) inset 0); iOS-Notch: viewport-fit cover; Overscroll-y contain (no Bounce); Touch-Precision: passive false in Favoriten touchstart (no 300ms Delay, aber battery-drain low); Vibration: if 'vibrate' in navigator && isMobile() (Chrome Android 91+, iOS Safari 13+ mit Permissions); No-Desktop-Hover on Mobile (mouseenter deaktiviert via Media-Query oder JS-check, aber CSS hover gilt für Touch-Hover in Chrome).

### 5.4. Accessibility & Barrierefreiheit
- **ARIA & Semantik**: Buttons: aria-label dynamisch (Back "Zurück", Add "Neues Element hinzufügen", Download "Templates herunterladen", Reset "Änderungen zurücksetzen", Clear-Favorites "Alle Favoriten löschen", Fullscreen "Vollbildmodus aktivieren" → "beenden", Organize "Karten organisieren" → "Fertig" on active, Tab "Favoritenleiste ausklappen" → "einklappen", Modal-Edit "Prompt bearbeiten", Save "Änderungen speichern", Copy "Prompt kopieren", Close "Modal schließen", Favorite "Zu Favoriten hinzufügen" → "Von Favoriten entfernen" star-toggle); Toggle-States: aria-expanded false/true on Expansion/Fullscreen/Tab (setAttribute in toggle*-Funktionen); Modals: Focus first input (promptTitleInputEl.focus() on openNewPromptModal/openCreateFolderModal, end selectRange length on toggleEditMode); Breadcrumb: spans role implicit link (click handler on .breadcrumb-link); Tree-Items: aria-disabled on .disabled (opacity 0.5 cursor not-allowed background transparent no hover); Favoriten-Items: aria-label `Kopiere: ${node.title}` → post-Copy `Kopiert: ${node.title}` setTimeout 2000ms reset `Kopiere: ${node.title}` (in copyToClipboard showSuccess if buttonElement && closest('.favorite-item')).
- **Keyboard-Navigation**: Global Escape (handleKeyDown: if contextMenu.visible hideContextMenu else if activeElement.classList.contains('rename-input') exitRenameMode closest card else if favoritesBarEl.classList.contains('is-expanded') collapseFavoritesBar else if modalEl.visible closeModal else if createFolderModalEl.visible closeModal(createFolderModalEl) else if moveItemModalEl.visible closeModal(moveItemModalEl)); Focus-Visible: :focus-visible outline none box-shadow 0 0 0 3px rgba(0,230,255,0.28) 0 0 0 6px rgba(139,92,246,0.18) (Buttons, Inputs); Tab-Sequenz: Top-Bar (Back → Breadcrumb → Organize → Add → Download → Reset → Clear-Favorites → Fullscreen → Logo) → Cards (tabindex implicit via natural order) → Tab-Button → Modals (trap focus on open, first input focus).
- **Screenreader-Support**: NVDA/TalkBack: Aria-Updates live (z. B. post-Copy "Kopiert: title" für VoiceOver); Semantik SVGs (stroke currentColor no title, aber aria-label on parent button); Initial-Badge textContent uppercase Letter (vorlesbar als "Kopiere: A für Alpha"); Reduced-Motion: Deaktiviert jiggle/grain/aurora/view-transitions/icon-rotation/copy-anim (prefers-reduced-motion reduce * none !important, inkl. backdrop-filter blur 0px).
- **Kontrast & Skalierbarkeit**: WCAG-AA (Fg-1 hsl(220,20%,95%) on Bg-0 hsl(228,12%,8%): Kontrast ~12:1; Accents >4.5:1; Initial-Badge: 8 Farben auf bg-0 alle >4.5:1 außer #f1fa8c Gelb auf --bg-1 hsl(228,12%,12%) für Lesbarkeit); Clamp/Rem (z. B. FS-1 clamp(28px,4vw,40px) für Titles); Hyphens auto overflow-wrap break-word in h3/textarea (pre-wrap word-wrap break-word line 1.75 margin-bottom 1.8rem flex-grow 1 background transparent border none resize none width 100% outline none padding 0 box-shadow none, editing: bg --bg-1 border glass-stroke radius 16px padding 0.8rem margin -0.8rem -0.8rem calc(1.8rem - 1.6rem) -0.8rem resize vertical focus box-shadow 0 0 0 3px rgba(0,230,255,0.28)).
- **Code-Referenzen**: `handleKeyDown(e)` (if e.key === 'Escape' chain: context visible hide, rename active exit, expanded collapse, modals close); `updateFavoriteButton(promptId)` (if !modal.visible || data-id !== promptId return + isFavorite = includes + starOutline.toggle hidden isFavorite + starFilled.toggle hidden !isFavorite + aria-label switch); `copyToClipboard` (aria-set if favorite post-success setTimeout 2000ms reset); `openModal` (focus first: promptTitleInputEl.focus() in openNewPrompt/openCreateFolder); `renderFolderTree` (if disabled classList.add('disabled') opacity 0.5 cursor not-allowed background transparent, click only if !disabled select toggle + confirm.disabled = false).

## 6. Performance & Optimierungen

- **Rendering-Optimierungen**: DOM-Clear vor Loop (innerHTML = ''); Limit 36 Items (slice(0,36) in renderView, erweiterbar IntersectionObserver); CloneNode(true) für SVGs (deep copy, no re-parse); RAF für Batches (z. B. renderedCards.forEach add 'is-visible' RAF, tooltip visible RAF); Throttling: Scroll-Handler ticking = true/false RAF updateParallax (const lastScrollY = scrollTop if !ticking window.requestAnimationFrame(() => {auroraContainerEl.style.transform = `translateY(${lastScrollY * 0.3}px)` ticking = false}) ticking = true – verhindert 60fps Jank).
- **GPU & CSS**: will-change transform/opacity/box-shadow/backdrop-filter auf .card (hover lift), .favorites-bar (expand max-height), .favorites-controls (bottom transition), .aurora-shape (parallax translateY); No Layout-Thrashing (transform/opacity/filter only, no width/height changes in anims); Backdrop-Filter blur(20px) saturate(200%) GPU (Fallback: opacity adjust in non-supporting Browsers).
- **Event-Handling**: Passive Events wo möglich (touchstart/move/end passive true in setupMobileSpecificFeatures für smooth Scroll/Swipe; touchstart passive false in Favoriten für präzise Klick no Zoom); PreventDefault in touchstart passive false (verhindert 300ms Delay bei Favoriten-Klicks); No Event-Bubbling (e.stopPropagation() in button clicks, modal backdrop).
- **Memory-Leaks vermeiden**: SetTimeout/RAF cleanup (clearTimeout in showFavoriteTooltip/hide, transitionend once in notification fade-out); No Infinite Loops (rekursiv findNodeById/Parent with early return if !items); DOM-Remove in closeModal (add 'hidden' setTimeout 300ms nach remove 'visible').
- **Fallbacks**: View-Transitions (!document.startViewTransition → direct updateDomFunction callback); Clipboard (!navigator.clipboard || !window.isSecureContext → textarea fallback append body focus select execCommand 'copy' remove); JSON-Parse (try/catch removeItem reload on error); No-Data (if !node error p red, empty folder p opacity 0.7).
- **Code-Referenzen**: `ticking` global (true/false in scroll handler für RAF-Throttle); `requestAnimationFrame` (in renderView forEach add is-visible, showFavoriteTooltip visible, notification show); `clearTimeout` (in hideFavoriteTooltip, notification setTimeout 2800ms); `preventDefault` (touchstart passive false in Favoriten, dragstart if !edit).

## 7. Erweiterungsmöglichkeiten & Wartung

- **Erweiterungen**: 
  - **Service-Worker**: sw.js in initApp navigator.serviceWorker.register('/sw.js') für Cache (z. B. precache templates.json/CSS/JS, runtime cache fetch); Offline: Cache-First für JSON, Network-First für Updates.
  - **Suche**: Füge <input type="search" placeholder="Suche Prompts..." id="search-input"> in Top-Bar hinzu, on 'input' event filterCards = childNodes.filter node => node.title.toLowerCase().includes(query.toLowerCase()) renderView(filterCards) (dynamische Filterung).
  - **Infinite-Scroll**: IntersectionObserver in containerEl für >36 Items (observe last card, if intersect load more via virtual slice).
  - **Themes**: localStorage 'theme' 'dark'/'light', CSS @media (prefers-color-scheme: dark/light) oder Toggle-Button in Top-Bar, set root.style.setProperty('--bg-0', value) dynamisch.
  - **Analytics**: In copyToClipboard localStorage 'usage' {id: {count: ++, lastUsed: Date.now()}} save + in renderFavoritesBar sort by count desc (favoritePrompts.sort((a,b) => usage[b.id].count - usage[a.id].count)).
  - **Export/Import**: Erweitere downloadCustomJson für CSV (map nodes to CSV rows) oder Import-Button file input parse JSON merge jsonData persist.
- **Wartung & Best Practices**: 
  - **Modularität**: Funktionen single-responsibility (z. B. `renderView` nur DOM, `persistJsonData` nur Save + Notification); Params explizit (Vivus {type:'delayed', duration:100, start:'manual'}, Sortable {animation:200, ghostClass:'sortable-ghost'}).
  - **Error-Handling**: Try-Catch überall (JSON.parse catch remove reload, fetch catch container error p, Clipboard catch fallback + notification error).
  - **Tests**: Unit (findNodeById: test recurse nested, copyToClipboard fallback execCommand, clearAllFavorites confirm empty array length check); Integration (renderFavoritesBar: assert initialBadge textContent === title.charAt(0).toUpperCase(), toggleFavoritesBarExpansion: assert both elements have 'is-expanded' class, icon rotation via getComputedStyle transform 'rotate(180deg)'); E2E (Puppeteer: click favorite assert clipboard content, toggle tab assert bottom calc and icon rotation, swipe assert history.back).
  - **Linting**: ESLint (no-unused-vars in toggleFavoriteStatus/updateFavoriteButton, strict mode); Stylelint (no-invalid-url in CSS vars, consistent spacing).
  - **Produktion**: Minify JS/CSS (z. B. Terser für JS, cssnano für CSS); CDN-Integrity für Libs (sha256 in script tags); HTTPS only (Clipboard/Vibration).
- **Troubleshooting**:
  - **Clipboard-Fehler**: If !window.isSecureContext fallback textarea (top/left -9999px opacity 0 focus select execCommand 'copy' append/remove body); Test in Incognito (no Cache).
  - **Vivus-Issues**: If SVG not animating check id unique (``icon-folder-${nodeId}``) and document.body.contains(parent) before new Vivus.
  - **Storage-Quota**: If quota exceeded (5MB limit) catch in persistJsonData show 'Speichern fehlgeschlagen!' (user lösche manuell via DevTools).
  - **Touch-Delay**: Passive false in touchstart (Favoriten) verhindert, aber battery-optimiert via {passive: true} in scroll/swipe.
  - **View-Transitions**: Fallback if !document.startViewTransition (Safari <15.4: direct callback, no slide/fade).

## 8. Vollständige Funktionsliste & Code-Mapping

- **initApp()** (Zeile 1-100): DOM-Query alle Elements (modalEl = getElementById('prompt-modal'), breadcrumbEl = 'breadcrumb', containerEl = 'cards-container', etc. + clearFavoritesBtn = getElementById('clear-favorites-button')), if fullscreenBtn fullscreenEnterIcon = query .icon-fullscreen-enter fullscreenExitIcon = .icon-fullscreen-exit, if organizeBtn organizeIcon = query .icon-organize doneIcon = .icon-done, if modalFavoriteBtn starOutlineIcon = query .icon-star-outline starFilledIcon = .icon-star-filled, svgTemplate* = getElementById('svg-template-*'), createGlobalTooltip() (div id 'favorite-tooltip' body append), setupEventListeners() (alle addEventListener, if clearFavoritesBtn addEventListener 'click' clearAllFavorites), checkFullscreenSupport() (if support body setAttribute data-fullscreen-supported true else remove + if fullscreenBtn remove), createContextMenu() (div class 'context-menu' body append + innerHTML 5 items + divider + click handler dispatch action), loadFavorites() (getItem parse try/catch []), if isMobile() setupMobileSpecificFeatures() (body classList.add('mobile') + containerEl addEventListener touchstart/move/end passive true handle* + history.replaceState {path:[],modalOpen:false} '' + window.onpopstate = handlePopState), loadJsonData(currentJsonFile).
- **setupEventListeners()** (Zeile 200-350): topbarBackBtn.addEventListener('click', () => if modalEl.classList.contains('visible') closeModal({fromBackdrop:true}) else if pathStack.length >0 navigateOneLevelUp()), fixedBackBtn.addEventListener('click', navigateToHome), appLogoBtn.addEventListener('click', navigateToHome), organizeBtn.addEventListener('click', toggleOrganizeMode), addBtn.addEventListener('click', e=>e.stopPropagation() addMenu.classList.toggle('hidden')), document.addEventListener('click', e=>if !addBtn.contains(e.target) && !addMenu.contains(e.target) addMenu.classList.add('hidden')), addMenu.addEventListener('click', e=>{const menuItem = e.target.closest('.add-menu-item') if !menuItem return const action = menuItem.dataset.action if action==='add-prompt' openNewPromptModal() else if action==='add-folder' openCreateFolderModal() addMenu.classList.add('hidden')}), downloadBtn.addEventListener('click', downloadCustomJson), resetBtn.addEventListener('click', resetLocalStorage), if clearFavoritesBtn clearFavoritesBtn.addEventListener('click', clearAllFavorites), if fullscreenBtn fullscreenBtn.addEventListener('click', toggleFullscreen) + document.addEventListener('fullscreenchange', updateFullscreenButton) + webkit/moz/MS variants, if favoritesExpandToggleBtn favoritesExpandToggleBtn.addEventListener('click', toggleFavoritesBarExpansion), modalCloseBtn.addEventListener('click', () => closeModal()), if copyModalButton copyModalButton.addEventListener('click', () => copyPromptText(copyModalButton)), if modalFavoriteBtn modalFavoriteBtn.addEventListener('click', () => {const promptId = modalEl.getAttribute('data-id') if promptId toggleFavoriteStatus(promptId)}), modalEditBtn.addEventListener('click', () => toggleEditMode(true)), modalSaveBtn.addEventListener('click', savePromptChanges), modalEl.addEventListener('click', e=>if e.target === modalEl e.stopPropagation() closeModal({fromBackdrop:true})), createFolderCancelBtn.addEventListener('click', () => closeModal(createFolderModalEl)), createFolderSaveBtn.addEventListener('click', saveNewFolder), createFolderModalEl.addEventListener('click', e=>if e.target === createFolderModalEl closeModal(createFolderModalEl)), moveItemCancelBtn.addEventListener('click', () => closeModal(moveItemModalEl)), moveItemConfirmBtn.addEventListener('click', confirmMoveItem), moveItemModalEl.addEventListener('click', e=>if e.target === moveItemModalEl closeModal(moveItemModalEl)), containerEl.addEventListener('click', handleCardContainerClick), containerEl.addEventListener('contextmenu', handleContextMenu), favoritesBarEl.addEventListener('contextmenu', handleContextMenu), containerEl.addEventListener('dragstart', handleDragStart), containerEl.addEventListener('dragover', handleDragOver), containerEl.addEventListener('dragenter', handleDragEnter), containerEl.addEventListener('dragleave', handleDragLeave), containerEl.addEventListener('drop', handleDrop), containerEl.addEventListener('dragend', handleDragEnd), promptFullTextEl.addEventListener('input', () => adjustTextareaHeight(promptFullTextEl)), document.addEventListener('keydown', handleKeyDown), containerEl.addEventListener('scroll', () => {lastScrollY = containerEl.scrollTop if !ticking window.requestAnimationFrame(() => {updateParallax() ticking = false}) ticking = true}), if favoritesContainerEl favoritesContainerEl.addEventListener('touchstart', e=>e.preventDefault(), {passive: false}).

## 9. Vollständige Fehlerbehebung & Validierung

- **Bekannte Issues behoben**: 
  - **Clear-Favorites-Button**: Voll funktional (HTML: <button id="clear-favorites-button" class="btn btn-ghost" aria-label="Alle Favoriten löschen" style="display: none;"> + SVG polygon Stern + line x1 18 y1 6 x2 6 y2 18; JS: clearFavoritesBtn = getElementById, if clearFavoritesBtn addEventListener 'click' clearAllFavorites, in renderFavoritesBar if length===0 clearBtn.style.display = 'none' else 'inline-flex').
  - **Tab-Positionierung**: Exakt (bottom calc(4.5rem + safe -1px) collapsed, calc(12rem + safe -1px) expanded, -1px für Border-Overlap ohne Gap; Mobile <420px calc(4.5rem + safe -1px)/calc(12rem + safe -1px), konsistent mit Bar max-height).
  - **Glassmorphism**: Vollständig (rgba 0.75 backdrop-blur 20px saturate 180% + ::before gradient-border 180deg acc-2→acc-1 opacity 0.6 hover 0.85 + ::after noise 0.2, border-bottom none für nahtlose Klebung).
  - **Icon-Richtung**: Korrekt (expand: points="18 15 12 9 6 15" Pfeil nach oben collapsed, rotate 180deg zu unten expanded; collapse: points="6 9 12 15 18 9" Pfeil nach unten).
  - **Initial-Badge**: Robust (node.title && trim().length >0 ? trim().charAt(0).toUpperCase() : '?'; CSS :nth-child(8n+x) background match zu Item border-color, e.g. 8n+1 #8b5cf6, 8n+7 #f1fa8c color --bg-1 für Kontrast).
  - **Copy-Animation**: Organisch (filter drop-shadow 0 0 8px acc-2 scale 1→1.15 600ms, kein box-shadow für no Kasten; checkmark scale 0.7→1.1→1 0.4s bounce).
  - **Mobile-Konsistenz**: Alle bottom calc(4.5/12rem + safe -1px), Tab 48x32px <420px, Initial 24px Title 60px Icon 18px, 'mobile-grid' add if innerWidth <768 (CSS height 38px padding adjust).
  - **Synchrone States**: toggleFavoritesBarExpansion toggelt 'is-expanded' auf BEIDE Bar + Controls (classList.toggle('is-expanded', isExpanded) für gleiche Klasse).
  - **Weitere Fixes**: Trim() einmal in initialLetter (keine Redundanz); Touchstart passive false nur Favoriten (no battery-drain in scroll); Aria-Reset 2000ms post-Copy; Notification timeout 2800ms transitionend once remove; Vivus if document.body.contains(parent) before new Instance (no leak); Sortable destroy on exitOrganizeMode; History state robust (|| {path:[],modalOpen:false} + filter Boolean in pathStack = state.path.map id=>findNodeById).
